/**
 * 访问者模式（Visitor Pattern）
 *
 * 对于某个对象或者一组对象，不同的访问者，产生的结果不同，执行操作也不同。
 * 使用了这个模式后就可以在不修改已有程序结构的前提下，通过添加额外的访问者来完成对已有代码功能的提升，它属于行为模式。
 *
 * 在实际系统中访问者模式通常是用来处理复杂的对象树结构的，而且访问者模式可以用来处理跨多个等级结构的树结构问题。
 *
 * 目的:
 * 封装一些施加于某种数据结构元素之上的操作，将数据结构与数据操作分离
 *
 * 优点：
 * 扩展性好，可以在不修改对象结构中的元素的情况下，为对象结构中的元素添加新的功能；
 * 符合单一职责原则，通过访问者将无关的行为分离，使职责单一；
 *
 * 缺点：
 * 违反了迪米特原则，因为具体元素对访问者公布细节；
 * 违反了依赖倒置原则，依赖了具体类，没有依赖抽象；
 * 对象结构变化困难，若对象结构发生了改变，访问者的接口和访问者的实现也都要发生相应的改变；
 *
 * 场景：
 * 对象结构中对象对应的类很少改变，但经常需要在此对象结构上定义新的操作；
 * 需要对一个对象结构中的对象进行很多不同的并且不相关的操作，而需要避免让这些操作"污染"这些对象的类，也不希望在增加新操作时修改这些类。
 *
 * ## 分派(Dispatch)
 * 根据对象的类型而对方法进行的选择，就是分派(Dispatch)，分派(Dispatch)又分为两种，即静态分派和动态分派。
 * 变量被声明时的类型叫做变量的静态类型(Static Type)，有些人又把静态类型叫做明显类型(Apparent Type)；
 * 而变量所引用的对象的真实类型又叫做变量的实际类型(Actual Type)。
 *
 * 静态分派(Static Dispatch)
 * 发生在编译时期，分派根据静态类型信息发生。
 * 在静态分派判断的时候，我们根据多个判断依据（即参数类型和个数）判断出了方法的版本，那么这个就是多分派的概念，
 * 因为我们有一个以上的考量标准，也可以称为宗量。所以JAVA是静态多分派的语言。
 *
 * 动态分派
 * 动态分派，与静态相反，它不是在编译期确定的方法版本，而是在运行时才能确定。
 * 而动态分派最典型的应用就是多态的特性
 *
 * 动态分派判断的方法是在运行时获取到实际引用类型，再确定方法的版本，
 * 而由于此时判断的依据只是实际引用类型，只有一个判断依据，所以这就是单分派的概念，
 * 这时我们的考量标准只有一个宗量，即变量的实际引用类型。
 * 相应的，这说明JAVA是动态单分派的语言。
 *
 * ## 访问者模式中的伪动态双分派
 * 访问者模式中使用的是伪动态双分派，所谓的动态双分派就是在运行时依据两个实际类型去判断一个方法的运行行为，
 * 而访问者模式实现的手段是进行了两次动态单分派来达到这个效果。
 *
 *
 * https://blog.csdn.net/u011109589/article/details/80240574
 */
package me.sunny.demo.dp.oop.behavioral.visitor;